---
layout: default
---

# Panel

## Moderator

* Irina Demeshko, Los Alamos National Laboratory, USA

## Panelists

* Hartmut Kaiser, Center for Computation & Technology at Louisiana State University, USA
* Laxmikant (Sanjay) Kale, Department of Computer Science, University of Illinois at Urbana-Champaign, USA
* Martin Berzins, Scientific Computing and Imaging Institute, University of Utah, USA
* Mike Bauer, NVIDIA, USA
* Thomas Fahringer, University of Innsbruck , Austria

## Panel's chosen questions

* Why should one choose to use AMT models?
* What kinds of applications will benefit from using AMT models and programming systems?
* For what kinds of applications is AMT-style programming better suited to creating maintainable code than message passing-style code?
* Are AMT programs more difficult to debug because it is (1) easier to create race conditions and (2) more difficult to get anything like a stack trace? What is being done to make debugging of large-scale AMT applications easier?
* What sort of language support is needed for AMT programming?
    - What advantage do newer languages like Go, Julia, etc., have for AMT programming, and can/should they displace C++ for scientific applications?
    - Many languages have added "await" or some variant as new keywords for processing asynchronous code. How important is this feature for the success of the AMT paradigm?
* How does one choose which AMT programming model among others?

## Outline

* Introduction of the panelists
* Discussion about panel's chosen questions
* Q&A with the audience
